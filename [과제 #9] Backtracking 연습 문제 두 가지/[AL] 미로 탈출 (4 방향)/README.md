## [AL] 미로 탈출 (4 방향)
---
- Backtracking 방법으로 입구에서 출구까지 탈출이 가능한지 알아보고, 가능하다면 탈출로를 찾아보자!
- **입력**
    - 첫 줄: `n`    # `n` `x` `n` 미로라는 의미
    - 두 번째 줄: `sx` `sy` `ex` `ey`   # 입구 칸 (`sx`, `sy`),  출구 칸 (`ex`, `ey`)
    - 세 번째 줄부터 n개의 줄은 미로를 나타낸다 (`1`은 장애물, `0`은 빈칸을 의미한다)
        - 각 줄은 길이가 `n`인 `0`과 `1`로 구성된 문자열임
        - 미로는 이차원 문자열 리스트 M에 저장함
- 여러분은 `find_way_from_maze` 함수를 호출하여, `M`에 탈출 경로를 찾아
    - 입구 칸에는 '`s`'를, 출구 칸에는 '`e`', 그 외 탈출 경로에 해당하는 칸에는 trace를 저장한다
    - `trace = '\u00B7'`으로 dot을 나타내는 문자로 선언되어 있으며, 탈출 경로를 그리기 위한 marker 역할을 한다
    - 탈출 경로가 있으면 `True`, 없으면` False`를 리턴한다
    - 주의: 현재 칸에서 동, 서, 남, 북 네 방향으로 인접한 빈 칸으로 이동가능하며, 이동할 때에는 반드시 **동쪽 -> 남쪽 -> 서쪽 -> 북쪽** 순서로 검사하여 이동해야 한다
- **출력**
    - 샘플 코드의 입출력 부분은 수정하지 말고 그대로 사용할 것!

### Pseudo Code:

```
find_way_from_maze(r, c) # 현재 칸 (r, c) 방문 중
	visited[r][c] = True
	if (r, c) == exit: return True
	   if 동쪽 이웃 칸이 빈 칸이고 미방문이라면:
		if find_way_from_maze(r, c+1):
			M[r][c+1] = trace  # trace는 dot으로 탈출경로를 표시하기 위함
			return True
	if 남쪽 이웃 칸이 빈 칸이고, 미방문이라면:
		...
	if 서쪽 이웃 칸이 빈 칸이고, 미방문이라면:
		...
	if 북쪽 이웃 칸이 빈 칸이고, 미방문이라면:
		...
	return False
```

### **예시 1**
입력
```
7
1 1 5 5
1111111
1000001
1111101
1000101
1011101
1000001
1111111
```
출력
```
#######
#s····#
#####·#
#   #·#
# ###·#
#    e#
#######


```
### **예시 2**
입력
```
7
3 3 5 5
1111111
1000001
1111101
1000101
1011101
1000001
1111111
```
출력
```
#######
#     #
##### #
#··s# #
#·### #
#····e#
#######


```

### **예시 3**
입력
```
11
3 3 9 9
11111111111
10100000101
10101110101
10101010101
10111010101
10001000101
10111011101
10001010001
10101011101
10100000001
11111111111
```
출력
```
###########
# #·····# #
# #·###·# #
# #s# #·# #
# ### #·# #
#   #···# #
# ###·### #
#   #·#   #
# # #·### #
# #  ····e#
###########


```

