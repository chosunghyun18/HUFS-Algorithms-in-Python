## [과제 #6] Quick, merge, heap 정렬 알고리즘 구현하여 비교해보기~
-----------------

Quick, merge, heap 정렬을 모두 구현해보고, 시간과 비교/교환-이동 횟수를 다양한 n에 대해 실행하여 비교해봅니다.

- 세 가지 정렬 알고리즘을 작성합니다. 대부분의 코드는 교재와 동영상에 나와 있어요.
    - ```quick_sort(A, first, last): A[first] ... A[last]```까지 quick sort하는 함수
    - ```merge_sort(A, first, last): A[first] ... A[last]```까지 merge sort하는 함수
    - h```eap_sort(A):``` A의 값들을 heap sort하는 함수 (heap 클래스를 정의할 필요 없이 함수로)
- 추가로 고려할 사항:
    - quick sort와 merge sort는 분할정복 알고리즘으로 하나의 값이 남을 때까지 분할하는 것이 기본 전략입니다. 그런데 굳이 하나가 남을때까지 분할할 필요는 없습니다. 경우에 따라서는 10과 40 사이의 상수 K에 대해서, K개 이하가 되면 분할을 멈추고 insertion sort로 정렬을 하면 더 빠르게 전체 정렬이 가능할 수도 있습니다
    - [추가 점수] 하나의 값이 남을 때까지 분할하는 quick, merge 정렬과 적당한 상수 K개 이하가 될 때까지만 분할하는 quick, merge 정렬을 함께 구현해 비교해보세요
- 램던한 수를 n개 생성하여, 리스트에에 저장하여, 세 개의 정렬 함수를 호출해 정렬하고 다음 세 값을 각각 기록합니다.
    - 수행시간: timeit 모듈을 이용합니다 (샘플 코드에 나온대로 하면 됩니다)
    - 비교횟수: 두 수를 비교하는 횟수를 기록합니다.
    - 교환횟수: 두 수가 교환(**swap**)되는 횟수를 기록합니다. 교환횟수에는 merge 정렬에서의 **이동 횟수**도 포함됩니다
    - **hint**: 비교와 교환횟수를 저장하는 변수를 global변수로 선언해 기록하는 게 편함!
- n의 값을 ``n = 100, 500, 1000, 5000, 10000, 50000, 100000, 500000`` 정도까지 다양하게 변화하면서 위의 세 가지 값이 어떻게 변하는지 기록하고 그 결과를 분석한 후 개인적인 느낌을 자유롭게 작성해봅니다. (도표나 그래프 등을 이용하면 더 효과적이겠죠?)
- 강의동영상과 교재에서 설명한 내용만으로 충분히 코드를 작성할 수 있기에 외부 코드를 참조하거나 사용하는 것은 금지합니다
- 코드는 컴파일 에러가 없어야 하고 올바르게 동작해야 합니다
- 코드는 구름에 제출하면 됩니다
- 레포트는 3장을 넘지 않게 해서 eclass에 제출합니다
